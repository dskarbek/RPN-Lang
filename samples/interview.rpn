{ uses library.rpn } #
{ uses array_lib.rpn } #

{ Some methods that implement questions from "Cracking the Coding Interview". These
are not going to be optimal solutions. RPN doesn't have the language features to
make optimal solutions and the point here is to demonstrate that the language is
complete enough to solve the problems at all. } #


{ is_unique #
    { Determine if a list is all unique values } #
    sort ->
    true
    for_n # $ 2 -
    {
        running_result :=
        last :=
        :: last ?! !=
        running_result ?! &&
    } for_n ->
    running_result :=
    #
    running_result ?!
} is_unique :=

test # { Empty List }
{
    is_unique ->
    $ 1 == &&
} register_test ->

test # { Singleton List }
{
    1
    is_unique ->
    $ 1 == &&
} register_test ->

test # { Unique Pair List }
{
    1 2
    is_unique ->
    $ 1 == &&
} register_test ->

test # { Matching Pair List }
{
    1 1
    is_unique -> !
    $ 1 == &&
} register_test ->

test # { Unique List }
{
    2 4 1 3
    is_unique ->
    $ 1 == &&
} register_test ->

test # { Non-unique List }
{
    4 1 2 1 3
    is_unique -> !
    $ 1 == &&
} register_test ->

test # { Non-numeric List }
{
    a b a
    is_unique -> !
    $ 1 == &&
} register_test ->

test # { Unique Non-numeric List }
{
    a b c
    is_unique ->
    $ 1 == &&
} register_test ->


{ { CHECK PERMUTATION
    Given two strings, determine whether they are permutations of each other. } #
    [] str2 array_init ->
    [] str1 array_init ->
    if # str1 array_size -> str2 array_size -> ==
    {
        str1 array_sort ->
        str2 array_sort ->
        str1 str2 array_equal ->
    }
    else #
    {
        false
    } if_else ->
} is_permutation :=

test # { is_permutation positive }
{
    abc cab is_permutation ->
} register_test ->

test # { is_permutation negative }
{
    abc cad is_permutation -> !
} register_test ->

test # { is_permutation vs empty }
{
    abc { } is_permutation -> !
} register_test ->

test # { is_permutation empty v empty }
{
    { } { } is_permutation ->
} register_test ->

test # { is_permutation size mis-match }
{
    abc abbaccab is_permutation -> !
} register_test ->



{ { IS PALINDRONE PERMUTATION
    Take a string and see if the non-space characters could be rearranged into a
    palindrone } #
} is_palindrone_permutation :=

test # { is_palindrone_permutation positive }
{
    { Tact Coa } is_palindrone_permutation ->
} register_test ->
run_tests ->
